{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\n\n// Define Pokemon type interface\n\nconst usePokemonData = () => {\n  _s();\n  const [allPokemon, setAllPokemon] = useState([]);\n  const [filteredPokemon, setFilteredPokemon] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedType, setSelectedType] = useState('');\n  const [pokemonTypes, setPokemonTypes] = useState([]);\n\n  // Fetch Pokemon data\n  useEffect(() => {\n    const fetchPokemon = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch('https://pokeapi.co/api/v2/pokemon?limit=150');\n        if (!response.ok) {\n          throw new Error('Failed to fetch Pokemon data');\n        }\n        const data = await response.json();\n\n        // Get detailed data for each Pokemon\n        const pokemonDetails = await Promise.all(data.results.map(async pokemon => {\n          const detailResponse = await fetch(pokemon.url);\n          return await detailResponse.json();\n        }));\n\n        // Transform data to our format\n        const formattedPokemon = pokemonDetails.map(pokemon => {\n          return {\n            id: pokemon.id,\n            name: pokemon.name,\n            types: pokemon.types.map(type => type.type.name),\n            image: pokemon.sprites.front_default\n          };\n        });\n\n        // Extract all unique Pokemon types\n        const allTypes = new Set();\n        formattedPokemon.forEach(pokemon => {\n          pokemon.types.forEach(type => {\n            allTypes.add(type);\n          });\n        });\n        setPokemonTypes(Array.from(allTypes).sort());\n        setAllPokemon(formattedPokemon);\n        setFilteredPokemon(formattedPokemon);\n      } catch (err) {\n        console.error('Error fetching Pokemon:', err);\n        setError('Failed to load Pokemon. Please try again later.');\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchPokemon();\n    // TODO: Maybe add a way to cancel fetch if component unmounts?\n  }, []);\n\n  // Filter Pokemon based on search term and type\n  useEffect(() => {\n    let result = allPokemon;\n    if (searchTerm) {\n      result = result.filter(pokemon => pokemon.name.toLowerCase().includes(searchTerm.toLowerCase()));\n    }\n    if (selectedType) {\n      result = result.filter(pokemon => pokemon.types.includes(selectedType));\n    }\n    setFilteredPokemon(result);\n    // not sure if this is the best way to filter, works for now\n  }, [searchTerm, selectedType, allPokemon]);\n  return {\n    pokemon: filteredPokemon,\n    loading,\n    error,\n    searchTerm,\n    setSearchTerm,\n    selectedType,\n    setSelectedType,\n    pokemonTypes\n  };\n};\n_s(usePokemonData, \"1TQ5gRJeEc9UYSyQ3MpbigdaC1k=\");\nexport default usePokemonData;","map":{"version":3,"names":["useState","useEffect","usePokemonData","_s","allPokemon","setAllPokemon","filteredPokemon","setFilteredPokemon","loading","setLoading","error","setError","searchTerm","setSearchTerm","selectedType","setSelectedType","pokemonTypes","setPokemonTypes","fetchPokemon","response","fetch","ok","Error","data","json","pokemonDetails","Promise","all","results","map","pokemon","detailResponse","url","formattedPokemon","id","name","types","type","image","sprites","front_default","allTypes","Set","forEach","add","Array","from","sort","err","console","result","filter","toLowerCase","includes"],"sources":["C:/Users/Vivek Sheel Thakral/Assignment1_PokemonApp/src/hooks/usePokemonData.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\n\r\n// Define Pokemon type interface\r\ninterface Pokemon {\r\n  id: number;\r\n  name: string;\r\n  types: string[];\r\n  image: string;\r\n}\r\n\r\nconst usePokemonData = () => {\r\n  const [allPokemon, setAllPokemon] = useState<Pokemon[]>([]);\r\n  const [filteredPokemon, setFilteredPokemon] = useState<Pokemon[]>([]);\r\n  const [loading, setLoading] = useState<boolean>(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [searchTerm, setSearchTerm] = useState<string>('');\r\n  const [selectedType, setSelectedType] = useState<string>('');\r\n  const [pokemonTypes, setPokemonTypes] = useState<string[]>([]);\r\n\r\n  // Fetch Pokemon data\r\n  useEffect(() => {\r\n    const fetchPokemon = async () => {\r\n      try {\r\n        setLoading(true);\r\n        const response = await fetch('https://pokeapi.co/api/v2/pokemon?limit=150');\r\n        \r\n        if (!response.ok) {\r\n          throw new Error('Failed to fetch Pokemon data');\r\n        }\r\n        \r\n        const data = await response.json();\r\n        \r\n        // Get detailed data for each Pokemon\r\n        const pokemonDetails = await Promise.all(\r\n          data.results.map(async (pokemon: { url: string, name: string }) => {\r\n            const detailResponse = await fetch(pokemon.url);\r\n            return await detailResponse.json();\r\n          })\r\n        );\r\n        \r\n        // Transform data to our format\r\n        const formattedPokemon: Pokemon[] = pokemonDetails.map((pokemon) => {\r\n          return {\r\n            id: pokemon.id,\r\n            name: pokemon.name,\r\n            types: pokemon.types.map((type: { type: { name: string } }) => type.type.name),\r\n            image: pokemon.sprites.front_default\r\n          };\r\n        });\r\n        \r\n        // Extract all unique Pokemon types\r\n        const allTypes = new Set<string>();\r\n        formattedPokemon.forEach(pokemon => {\r\n          pokemon.types.forEach(type => {\r\n            allTypes.add(type);\r\n          });\r\n        });\r\n        \r\n        setPokemonTypes(Array.from(allTypes).sort());\r\n        setAllPokemon(formattedPokemon);\r\n        setFilteredPokemon(formattedPokemon);\r\n        \r\n      } catch (err) {\r\n        console.error('Error fetching Pokemon:', err);\r\n        setError('Failed to load Pokemon. Please try again later.');\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchPokemon();\r\n    // TODO: Maybe add a way to cancel fetch if component unmounts?\r\n  }, []);\r\n\r\n  // Filter Pokemon based on search term and type\r\n  useEffect(() => {\r\n    let result = allPokemon;\r\n    \r\n    if (searchTerm) {\r\n      result = result.filter(pokemon => \r\n        pokemon.name.toLowerCase().includes(searchTerm.toLowerCase())\r\n      );\r\n    }\r\n    \r\n    if (selectedType) {\r\n      result = result.filter(pokemon => \r\n        pokemon.types.includes(selectedType)\r\n      );\r\n    }\r\n    \r\n    setFilteredPokemon(result);\r\n    // not sure if this is the best way to filter, works for now\r\n  }, [searchTerm, selectedType, allPokemon]);\r\n\r\n  return {\r\n    pokemon: filteredPokemon,\r\n    loading,\r\n    error,\r\n    searchTerm,\r\n    setSearchTerm,\r\n    selectedType,\r\n    setSelectedType,\r\n    pokemonTypes\r\n  };\r\n};\r\n\r\nexport default usePokemonData; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}